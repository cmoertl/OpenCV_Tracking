/**
* @file bg_sub.cpp
* @brief Background subtraction tutorial sample code
* @author Domenico D. Bloisi
*/

//opencv
#include "opencv2/core/core.hpp"
#include <vector>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include "opencv2/imgproc/imgproc.hpp"
#include <opencv2/video/tracking.hpp>


//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>
#include <string.h>
#include <algorithm>
using namespace cv;
using namespace std;

// Global variables
Mat frame, diff, diff1; //current frame
Mat oldframe, frame1;
Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
Ptr<BackgroundSubtractorGMG> pMOGG;
int keyboard; //input from keyboard
int edgeThresh = 1;
int lowThreshold;
int const max_lowThreshold = 100;
int ratio = 3;
int kernel_size = 3;
char* window_name = "Edge Map";
Mat src, src_gray, srcwe;
Mat dst, detected_edges;
int thresh = 40;
int max_thresh = 255;
RNG rng(12345);

int morph_elem = 0;
int morph_size = 0;
int morph_operator = 1;
int const max_operator = 4;
int const max_elem = 2;
int const max_kernel_size = 21;

char* window_name1 = "Morphology Transformations Demo";

/** Function Headers */
void Morphology_Operations(int, void*);


typedef std::vector<std::vector<cv::Point> > Contours;
typedef std::vector<cv::Vec4i> Hierarchy;
void help();
void processVideo(char* videoFilename);
void processImages(char* firstFrameFilename);
void thresh_callback(int, void*);
Contours contours;
Hierarchy hierarchy;
/// Function header
void thresh_callback(int, void*);
Mat MyBackgroundSubtraction(Mat background, Mat current);
Mat temp1, temp2, img1, img2;

int main()
{

	namedWindow("Frame");
	namedWindow("FG Mask MOG");
	namedWindow("FG Mask MOG 2");
	src = imread("vlcsnap-2014-01-09-10h48m55s164.png", 1);
	if (src.empty())
	{
		cout << "Bild wurde nicht geladen";
	}
	//create Background Subtractor objects
	pMOG = new BackgroundSubtractorMOG(); //MOG approach
	pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach
	//processImages("C:\\Users\\Christopher\\Desktop\\111_png\\111_png\\input\\428.png");
	processVideo("20131004_14-16-24.asf");
	//processVideo("C:\\Users\\Christopher\\Desktop\\Bilder\\Video_001.avi");

	//destroy GUI windows
	destroyAllWindows();
	return EXIT_SUCCESS;






	waitKey(0);

	//cout << A << endl;
	//system("pause");
	return 0;
}


void removePepperNoise(cv::Mat &mask)
{
	for (int y = 2; y < mask.rows - 2; y++) {
		uchar *pUp2 = mask.ptr(y - 2);
		uchar *pUp1 = mask.ptr(y - 1);
		uchar *pThis = mask.ptr(y);
		uchar *pDown1 = mask.ptr(y + 1);
		uchar *pDown2 = mask.ptr(y + 2);
		pThis += 2;
		pUp1 += 2;
		pUp2 += 2;
		pDown1 += 2;
		pDown2 += 2;

		for (int x = 2; x < mask.cols - 2; x++) {
			uchar value = *pThis; // Get this pixel value (0 or 255). // Check if this is a black pixel that is surrounded by white pixels
			if (value == 0) {
				bool above, left, below, right, surroundings;
				above = *(pUp2 - 2) && *(pUp2 - 1) && *(pUp2) && *(pUp2 + 1) && *(pUp2 + 2);
				left = *(pUp1 - 2) && *(pThis - 2) && *(pDown1 - 2);
				below = *(pDown2 - 2) && *(pDown2 - 1) && *(pDown2) && *(pDown2 + 1) && *(pDown2 + 2);
				right = *(pUp1 + 2) && *(pThis + 2) && *(pDown1 + 2);
				surroundings = above && left && below && right;
				if (surroundings == true) {
					// Fill the whole 5x5 block as white. Since we know
					// the 5x5 borders are already white, we just need to
					// fill the 3x3 inner region.
					*(pUp1 - 1) = 255;
					*(pUp1 + 0) = 255;
					*(pUp1 + 1) = 255;
					*(pThis - 1) = 255;
					*(pThis + 0) = 255;
					*(pThis + 1) = 255;
					*(pDown1 - 1) = 255;
					*(pDown1 + 0) = 255;
					*(pDown1 + 1) = 255;
					// Since we just covered the whole 5x5 block with
					// white, we know the next 2 pixels won't be black,
					// so skip the next 2 pixels on the right.
					pThis += 2;
					pUp1 += 2;
					pUp2 += 2;
					pDown1 += 2;
					pDown2 += 2;
				}
			}
			// Move to the next pixel on the right.
			pThis++;
			pUp1++;
			pUp2++;
			pDown1++;
			pDown2++;
		}
	}
}

void processVideo(char* videoFilename) {
	//create the capture object
	VideoCapture capture(videoFilename);
	if (!capture.isOpened()){
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}
	int i = 0;
	//read input data. ESC or 'q' for quitting
	while ((char)keyboard != 'q' && (char)keyboard != 27){
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			exit(EXIT_FAILURE);
		}

		absdiff(frame, src, temp1);
		cvtColor(temp1, src_gray, CV_BGR2GRAY);
		blur(src_gray, src_gray, Size(3, 3));
		src_gray = src_gray > 30;
		Mat erodeElement = getStructuringElement(MORPH_RECT, Size(5, 5));
		//dilate with larger element so make sure object is nicely visible
		Mat dilateElement = getStructuringElement(MORPH_RECT, Size(8, 8));

		//erode(src_gray, src_gray, erodeElement);

		
		dilate(src_gray, src_gray, dilateElement);
		/// Create Window
		char* source_window = "Source";
		//	namedWindow(source_window, CV_WINDOW_AUTOSIZE);
		//	imshow(source_window, diff);

		createTrackbar(" Threshold:", "Source", &thresh, max_thresh, thresh_callback);
		thresh_callback(0, 0);
		imshow("Grey", src_gray);
		keyboard = waitKey(30);
		oldframe = diff;
		i++;
	}
	//delete capture object
	capture.release();
}

void thresh_callback(int, void*)
{
	Mat threshold_output;
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;

	/// Detect edges using Threshold
	threshold(src_gray, threshold_output, thresh, 255, THRESH_BINARY);
	/// Find contours
	findContours(threshold_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0));
	//matchShapes()


	//std::vector<std::vector<cv::Point> > contours_poly(contours.size());
	//for (int i = 0; i < contours.size(); i++) {
	//	approxPolyDP(cv::Mat(contours[i]), contours_poly[i], 5, true);
	//}

	// merge all contours into one vector
	//std::vector<cv::Point> merged_contour_points;
	//for (int i = 0; i < contours_poly.size(); i++) {
	//	for (int j = 0; j < contours_poly[i].size(); j++) {
	//		merged_contour_points.push_back(contours_poly[i][j]);
	//	}
	//}
	//std::vector<cv::Point> hull;
	//cv::convexHull(cv::Mat(merged_contour_points), hull);
	//cv::Mat hull_points(hull);
	//cv::RotatedRect rotated_bounding_rect = minAreaRect(hull_points);


	/// Find the rotated rectangles and ellipses for each contour
	vector<RotatedRect> minRect(contours.size());
	vector<RotatedRect> minEllipse(contours.size());

	for (int i = 0; i < contours.size(); i++)
	{

		if (contours[i].size() > 60 && contours[i].size() <800)
		{
			minRect[i] = minAreaRect(Mat(contours[i]));
			minEllipse[i] = fitEllipse(Mat(contours[i]));
		}
	}

	/// Draw contours + rotated rects + ellipses
	Mat drawing = Mat::zeros(threshold_output.size(), CV_8UC3);
	for (int i = 0; i < contours.size(); i++)
	{
		if (contours[i].size() > 60 && contours[i].size() <800)
		{
			Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			// contour
			drawContours(frame, contours, i, color, 1, 8, vector<Vec4i>(), 0, Point());
			// ellipse
			ellipse(frame, minEllipse[i], color, 2, 8);
			// rotated rectangle
			Point2f rect_points[4]; minRect[i].points(rect_points);
			for (int j = 0; j < 4; j++)
				line(frame, rect_points[j], rect_points[(j + 1) % 4], color, 1, 8);

		}
	}
	//removePepperNoise(drawing);
	/// Show in a window
	namedWindow("Contours", CV_WINDOW_AUTOSIZE);
	imshow("Contours", frame);
	imshow("Threshold", threshold_output);
}
